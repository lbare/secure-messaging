import sqlite3
import uuid
import src.lib.basic_crypto as basic_crypto
import time
import os


def sanitize(s_input: str):
    """
    There is a location in the database section where we use a direct string substitution in a SQL query
    The value subbed in is NOT a user generated input, it is an internal user id generated by the server
    However, just to be safe, the input is sanitized to prevent SQL injection attacks from unforseen vectors
    :param s_input: The input to be sanitized
    :return: A sanitized input
    """
    return "".join(c for c in s_input if c.isalnum())


class DatabaseError(Exception):
    pass


class DatabaseMessage:
    """
    The DatabaseMessage is used to provide a convenient way of keeping the message, sender and timestamp together when
    moving message data between the handler and the UI
    """

    def __init__(self, message, timestamp, sender):
        self.message = message
        self.timestamp = timestamp
        self.sender = sender

    def __lt__(self, other):
        return other.timestamp > self.timestamp

    def __gt__(self, other):
        return other.timestamp < self.timestamp

    def __eq__(self, other):
        return other.timestamp == self.timestamp

    def __repr__(self):
        return f"{self.timestamp} {self.sender}:{self.message}"


class ClientDatabaseHandler:
    """
    The database handler used by the clients. Stores local user data, the conversation history of users, and user contacts
    """

    def __init__(self):
        self.database = None
        # The key used to encrypt/decrypt messages that is encrypted under the user password
        self.decrypter = None

    def _initialize_database(self, username):
        """
        Given a username, connect to the relevant database, or create it if it doesnt exist
        :param username: The username of the client
        :return: None
        """
        if self.database is not None:
            raise DatabaseError("Database connection already open, please log out before attempting to open another "
                                "connection")
        # This is not an SQL Injection vulnerability, an attacker could potentially attach to other db files,
        # but if they're on the computer they could do that anyways
        self.database = sqlite3.connect(f"{sanitize(username)}.db", check_same_thread=False)
        self.database.execute('''CREATE TABLE IF NOT EXISTS localUser(
            USERNAME TEXT PRIMARY KEY,
            PASSWORD_HASH BLOB,
            USER_ID INT,
            DECRYPTER BLOB,
            NONCE BLOB,
            TAG BLOB
        )''')
        self.database.execute('''CREATE TABLE IF NOT EXISTS contact(
            USERNAME TEXT PRIMARY KEY,
            ID INT
            )''')

    def _close_database(self):
        if self.database is None:
            return
        self.database.close()
        self.database = None
        self.decrypter = None

    def login(self, username, password):
        """
        Given username and password, attempt a local login
        :param username: The username of the user
        :param password: The users password
        :return: The user_id if it is successful, False if it is not
        """
        self._initialize_database(username)
        # Hash the password for comparison
        password_hash = basic_crypto.hash_password(password)
        for result in self.database.execute('''SELECT USER_ID, DECRYPTER, NONCE, TAG 
                                                FROM localUser WHERE PASSWORD_HASH = ?''', (password_hash,)):
            if len(result) == 0:
                return False
            user_id = result[0]
            decrypter_encrypted = result[1]
            decrypter_nonce = result[2]
            tag = result[3]
            # Decrypt the decrypter using the password
            self.decrypter = basic_crypto.decrypt_message(decrypter_nonce, tag, decrypter_encrypted,
                                                          basic_crypto.make_AES_key(password))
            return user_id

    def sign_up(self, username, password, user_id):
        """
        Given a username, password, and user_id create a new user locally
        :param username: the username of the new user
        :param password: the new users password
        :param user_id: the user id obtained from the server
        :return: None
        """
        self._initialize_database(username)
        # Create a new decrypter
        plain_decrypter = basic_crypto.generate_key()
        # Encrypt it using the password
        nonce, tag, decrypter = basic_crypto.encrypt_message(plain_decrypter,
                                                             basic_crypto.make_AES_key(password))
        # Hash the password for storage
        password_hash = basic_crypto.hash_password(password)
        self.database.execute('''INSERT INTO localUser(USERNAME, PASSWORD_HASH, USER_ID, DECRYPTER, NONCE, TAG)
            VALUES(?,?,?,?,?,?)''', (username, password_hash, user_id, decrypter, nonce, tag))

        self.database.commit()
        self._close_database()

    def logout(self):
        self._close_database()

    def add_contact(self, user_id, user_name):
        """
        Add a contact into the database
        :param user_id: The id of the user obtained from the server
        :param user_name: The contacts username
        :return: None
        """
        self.database.execute(f'''CREATE TABLE IF NOT EXISTS message{sanitize(str(user_id))}(
            TIMESTAMP INT PRIMARY KEY,
            SENDER TEXT,
            MESSAGE BLOB,
            NONCE BLOB,
            TAG BLOB)''')
        self.database.execute('''INSERT INTO contact(USERNAME, ID)
            VALUES(?,?)''', (user_name, user_id))
        self.database.commit()

    def add_message(self, user_id, message, timestamp, sender):
        """
        Add a message into the database associated with a given conversation
        :param user_id: The user_id of the client that the local user is in conversation with
        :param message: The message content
        :param timestamp: The message timestamp
        :param sender: The sender, either the same user as referenced by user_id or the local user
        :return: None
        """
        # Encrypt the message
        nonce, tag, encrypted_message = basic_crypto.encrypt_message(message.encode(), self.decrypter)
        # Store the encrypted message
        self.database.execute(f'''INSERT INTO message{sanitize(str(user_id))}(TIMESTAMP, SENDER, MESSAGE, NONCE, TAG)
            VALUES(?,?,?,?,?)''', (timestamp, sender, encrypted_message, nonce, tag))

        self.database.commit()

    def get_id(self, contact_name):
        """
        Given a name, get a user_id
        :param contact_name: name of contact
        :return: the contacts user_id or False of no user exists with that name
        """
        user_id = None
        for contact in self.database.execute('''SELECT ID FROM contact WHERE USERNAME = ?''', (contact_name,)):
            user_id = contact[0]
        if user_id is None:
            return False
        return user_id

    def get_messages(self, contact_name):
        """
        Given a contact name, return the decrypted conversation with the messages in order by timestamp
        :param contact_name:
        :return:
        """
        user_id = None
        messages = []
        # Get the user_id associated with name
        for contact in self.database.execute('''SELECT ID FROM contact WHERE USERNAME = ?''', (contact_name,)):
            user_id = contact[0]
        if user_id is None:
            return False
        try:
            # Grab and decrypt all messages from conversation
            for entry in self.database.execute(f'''SELECT TIMESTAMP, SENDER, MESSAGE, NONCE, TAG
                                                    FROM message{sanitize(str(user_id))}'''):
                timestamp = entry[0]
                sender = entry[1]
                message_enc = entry[2]
                nonce = entry[3]
                tag = entry[4]
                # decrypt message data using decrypter as key
                message = basic_crypto.decrypt_message(nonce, tag, message_enc, self.decrypter).decode()
                messages.append(DatabaseMessage(message, timestamp, sender))

            messages.sort()
        except sqlite3.OperationalError:
            # if the contact has no messages
            return []
        return messages

    def delete_conversation(self, contact_name):
        """
        Given a username, delete conversation with that user from table
        :param contact_name: name of contact that you wish to delete conversation
        :return: True if succeeded, False if user doesnt exist
        """
        user_id = None
        for contact in self.database.execute('''SELECT ID FROM contact WHERE USERNAME = ?''', (contact_name,)):
            user_id = contact[0]
        if user_id is None:
            return False
        self.database.execute(f'''DROP TABLE IF EXISTS message{sanitize(str(user_id))}''')
        self.database.commit()
        return True

    def get_username(self, user_id):
        """
        Given a user_id get the username associated with it
        :param user_id: Id of relevant user
        :return: the username associated with the ID
        """
        user_request = self.database.execute('''SELECT USERNAME FROM contact 
            WHERE ID = ? ''', (user_id,))
        username = None
        for i in user_request:
            username = i[0]
        return username

    def delete_user(self, username):
        """
        Delete a user given a username
        :param username: username of user to be deleted
        :return: None
        """
        self._close_database()
        os.remove(f"{sanitize(username)}.db")


class ServerDatabaseHandler:
    """
    The server database handler is used by the server to create new users, authenticate users, and delete users
    """
    def __init__(self):
        self.database = None
        self.initialize_database()

    def initialize_database(self):
        """
        Create the credentials database or connect to it if it already exists
        :return: Mpme
        """
        self.database = sqlite3.connect('credentials.db', check_same_thread=False)
        self.database.execute('''CREATE TABLE IF NOT EXISTS users(
        ID INT PRIMARY KEY,
        USERNAME TEXT,
        PASSWORD_HASH BLOB
        )''')

    def insert_new_user(self, username, password):
        """
        Create a new user and insert it into the database
        :param username: The username of the new user
        :param password: The password of the new user
        :return: False if unsuccessful, the new user_id if successful
        """
        # Create the new user id, truncate it to a viable size
        user_id = uuid.uuid4().int % 1000_0000_0000_0000
        # hash the password for storage
        password_hash = basic_crypto.hash_password(password)
        # check if the user already exists
        cursor = self.database.cursor()
        cursor.execute('''SELECT * FROM users 
            WHERE USERNAME = ?''', (username,))
        result = cursor.fetchone()
        if result:
            return False

        # insert the new user
        self.database.execute('''INSERT INTO users(ID, USERNAME, PASSWORD_HASH)
                VALUES(?,?,?)''', (user_id, username, password_hash))
        self.database.commit()
        return user_id

    def get_user(self, user_id):
        """
        given a user id, return the username, user_id and password hash
        :param user_id: the user_id
        :return: the username, user_id and password hash
        """
        user_request = self.database.execute('''SELECT * FROM users 
            WHERE ID = ? ''', (user_id,))
        user = {}
        for i in user_request:
            user["user_id"] = i[0]
            user["username"] = i[1]
            user["password_hash"] = i[2]
        return user

    def get_user_by_name(self, username):
        """
        Given username get user_id
        :param username: the username
        :return: the related user_id
        """
        user_request = self.database.execute('''SELECT ID FROM users 
            WHERE USERNAME = ? ''', (username,))
        user_id = None
        for i in user_request:
            user_id = i[0]
        return user_id

    def delete_user(self, user_id):
        """
        delete a user given a user_id
        :param user_id: the user_id
        :return:
        """
        self.database.execute('''DELETE FROM users WHERE ID = ?''', (user_id,))
        self.database.commit()

    def login(self, username, password):
        """
        Given a username and password, authenticate the user
        :param username: the username of the user
        :param password: the related password
        :return: an empty dict if login failed, a populated one if successful
        """
        password_hash = basic_crypto.hash_password(password)
        user_request = self.database.execute('''SELECT * FROM users 
            WHERE USERNAME = ? AND PASSWORD_HASH = ? ''', (username, password_hash))
        user = {}
        for i in user_request:
            user["user_id"] = i[0]
            user["username"] = i[1]
            user["password_hash"] = i[2]
        return user


def test_sign_up():
    db = ClientDatabaseHandler()
    db.sign_up("Connor-Ebert", "password", 1)
    db.add_contact(2, "Bob")
    db.add_message(2, "Hi", int(time.time()), "Bob")
    db.logout()


def test_login_and_message_set_and_get():
    db = ClientDatabaseHandler()
    db.login("Connor-Ebert", "password")
    db.add_message(2, "hello", int(time.time()), "Me")
    time.sleep(1)
    db.add_message(2, "how", int(time.time()), "Bob")
    time.sleep(1)
    db.add_message(2, "h", int(time.time()), "Me")
    print(db.get_messages("Bob"))
    db.logout()


def server_test_login():
    db = ServerDatabaseHandler()
    user_id = db.insert_new_user("Connor", "password")
    print(db.get_user(user_id))
    print(db.login("Connor", "password"))


if __name__ == '__main__':
    test_login_and_message_set_and_get()
